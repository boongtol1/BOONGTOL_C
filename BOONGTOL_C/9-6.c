#include <stdio.h>

int main(void)
{
	double a = 10;             // 변수 선언과 초기화
	int* p = &a;            // 포인터 선언과 동시에 a를 가리키도록 초기화
	double* pd;             // double형 변수를 가리키는 포인터

	pd = p;                 // 포인터 p 값을 포인터 pd에 대입(늦은 초기화!) // *pd 값의 첫 주소에 *p의 값의 첫 주소를 대입해라!
	printf("%lf\n", *pd);   // pd가 가리키는 변수의 값 출력 // *p의 해석?--> 포인터 p가 가르키는 실제 값(a)!

	return 0;
}
// 0.000000 이 나오는 이유?--> int형 값을 double형 형식으로 출력하면 정보 손실이 발생할 수 있으며, 이는 예상치 못한 결과를 초래할 수 있습니다.(쓰레기 값 때문!!)
// %lf 형식 지정자는 double형 값을 출력하도록 사용됩니다.--> 전체를 인식하므로 쓰레기 값까지 인식!-->0.000000이 나오는 이유!!!
// int형 변수 a는 4바이트(32비트) 크기를 가지며, double형 변수는 8바이트(64비트) 크기를 가집니다. 
// 따라서 포인터 pd는 a의 값을 double형으로 해석하려고 하며, 이 과정에서 의미 없는 값이 나올 수 있습니다. 이는 printf 함수에서 0.000000이 출력되는 원인입니다.
// 9행의 해석?--> 우변--> int 형태의 값을 나타내는 변수(a)의 메모리의 주소를 p라 한다. 이때 p?--> 4개의 셀(바이트)을 할당!
// 좌변--> 아직은 모르지만 double 형태의 값을 나타내는 변수(?)의 메모리의 주소의 첫부분을 pd 라고 한다.pd?-->8개의 셀(바이트) 할당! 
// 변수의 메모리 주소를 언급할 때 일반적으로 변수의 시작 주소(starting address)만을 말합니다.
// 포인터 변수에 일반 숫자를 입력하는 것은 잘못된 메모리 접근을 초래할 수 있다!
// 포인터 변수에는 포인터만 입력가능하다!
// 9행?--> p의 존재정보가 pd 로 복사된다! // p의 존재정보?--> 변수 a(int 형태 , 4바이트) 가 메모리 상에 저장된 처음주소!
// double* pd;는 실수형 변수(8바이트)의 주소를 저장할 수 있는 포인터 변수다.
// p든 pd든 포인터의 크기는 일정하다!(64비트에서는 8바이트로 일정!)
// 핵심 key?--> *p 와 *pd를 비교한다!!!
// 변수 a와 포인터변수 p의 메모리공간은 서로 겹치지 않는다! --> why?--> 컴파일러와 운영체제가 메모리를 관리하는 방식 때문.
// 실제로, 운영체제와 컴파일러는 선언된 존재들끼리 동일한 메모리 공간을 공유하지 않도록 메모리를 관리 합니다.
// pd를 온전히 해석할려면 반드시 *pd 가 필요하다!(9행!)
// %d는 int 타입을 처리하는 형식 지정자이다!!--> 4바이트 이상의 값을 입력하면 첫 4바이트만 인식합니다.
// 정수를 %lf 형식 지정자로 출력하면, 이는 잘못된 형식 지정자로 인해 예상치 못한 동작이나 정의되지 않은 동작(Undefined Behavior)이 발생할 수 있습니다. 
// 5행이 double 6행 , 7행이 int 일때 6행에서 double이 아니면 경고 발생 but 실행시 정상작동하는 이유는?--> 뭐 어쩌라고 하고 continue 되기 때문!!
// 이해의 key?--> 그림 필기해논거 보기!!!