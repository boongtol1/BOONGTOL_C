#include <stdio.h>

int main(void)
{
	int a = 10;             // 변수 선언과 초기화
	int* p = &a;            // 포인터 선언과 동시에 a를 가리키도록 초기화
	double* pd;             // double형 변수를 가리키는 포인터

	pd = p;                 // 포인터 p 값을 포인터 pd에 대입
	printf("%d\n", *pd);   // pd가 가리키는 변수의 값 출력

	return 0;
}
// 0.000000 이 나오는 이유?--> int형 값을 double형 형식으로 출력하면 정보 손실이 발생할 수 있으며, 이는 예상치 못한 결과를 초래할 수 있습니다.
// %lf 형식 지정자는 double형 값을 출력하도록 사용됩니다.
// int형 변수 a는 4바이트(32비트) 크기를 가지며, double형 변수는 8바이트(64비트) 크기를 가집니다. 
// 따라서 포인터 pd는 a의 값을 double형으로 해석하려고 하며, 이 과정에서 의미 없는 값이 나올 수 있습니다. 이는 printf 함수에서 0.000000이 출력되는 원인입니다.
// 9행의 해석?--> 우변--> int 형태의 값을 나타내는 변수(a)의 메모리의 주소를 p라 한다. 이때 p?--> 4개의 셀(바이트)을 할당!
// 좌변--> 아직은 모르지만 double 형태의 값을 나타내는 변수(?)의 메모리의 주소의 첫부분을 pd 라고 한다.pd?-->8개의 셀(바이트) 할당! 
// 변수의 메모리 주소를 언급할 때 일반적으로 변수의 시작 주소(starting address)만을 말합니다.
// 포인터 변수에 일반 숫자를 입력하는 것은 잘못된 메모리 접근을 초래할 수 있다!
// 포인터 변수에는 포인터만 입력가능하다!
// 9행?--> p의 존재정보(과정 전체)가 pd 로 복사된다! // p의 존재정보?--> 변수 a(int 형태 , 4바이트) 가 메모리 상에 저장된 처음주소!
// double* pd;는 실수형 변수(8바이트)의 주소를 저장할 수 있는 포인터 변수다.
// p든 pd든 포인터의 크기는 일정하다!(64비트에서는 8바이트로 일정!)
// 핵심 key?--> *p 와 *pd를 비교한다!!!
// 변수 a와 포인터변수 p의 메모리공간은 서로 겹치지 않는다! --> why?--> 컴파일러와 운영체제가 메모리를 관리하는 방식 때문.